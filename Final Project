# polynomial.py starts here

# Irash Gilani
# 846852
# Polynomial Object for the Final Project

# Variable Dictionary:
#
#
#
#
#
#
#
#

class Polynomial:
    def __init__(self, coefficients):
        # the input variable "coefficients" is an array
        # the coefficients are assumed to be in standard form 
        self.__coeffs = []
        
        # the code below is for ignoring the leading zeroes in the input list,
        # then appending the rest of the numbers to self.__coeffs
        self.__pastleadingzeroes = False
        
        for idx in range(len(coefficients)):
            if coefficients[idx] != 0:
                self.__pastleadingzeroes = True
            if self.__pastleadingzeroes == True:
                self.__coeffs.append(coefficients[idx])
                
    def get_order(self):
    # a function for getting the order of the polynomial
        
        for exp in range(len(self.__coeffs) - 1, -1, -1):
        # goes backwards through self.__coeffs to find the exponent of the first variable    
            if exp == len(self.__coeffs) - 1:
                return exp
        
    def f(self, x):
    # a function for getting the value of y using the polynomial and an
    # inputted x value 
        self.__y = 0
        self.__exponent = 0
        
        for idx in range(len(self.__coeffs) - 1, -1, -1):
            # a for loop that goes from the last coefficient in self.__coeffs
            # to the first coefficient
            
            if idx == len(self.__coeffs) - 1:
                # if the loop is on the last coefficient in self.__coeffs,
                # add the coefficient times x without an exponent
                self.__y += self.__coeffs[idx] * x
            else:
                # if the loop is on any other number, the exponent is increased by one
                # with every step, and is 
                self.__exponent += 1
                self.__y += (self.__coeffs[idx]) * x**self.__exponent
        
        return self.__y
                
                
    
    def __str__(self):
        # a function for printing the polynomial including its exponents
        self.__polystring = ""
        self.__index = 0
        
        for exp in range(len(self.__coeffs) - 1, -1, -1):
            # goes backwards through self.__coeffs, using the step value as the exponent and increasing
            # self.__index by one with each step, and adding each value in the polynomial using the
            # exponent and self.__index
            self.__polystring += (("%dx^%d" % (self.__coeffs[self.__index], exp)))
            self.__index += 1
            
            if exp != 0:
                # adds a plus sign if the loop is not on the last value in self.__coeffs
                self.__polystring += " + "
        
        return self.__polystring
                
                
            
        
# polynomial.py ends here

# IVT.py starts here

# Irash Gilani
# 846852
# IVT Object for the Final Project

# Variable Dictionary:
#
#
#
#
#
#
#

#from polynomial import Polynomial

class IVT():
# an object for approximating the zeroes of a polynomial using
# two x values
    def __init__(self, Poly, x1, x2):
        
    
        self.__x1 = x1
        self.__x2 = x2
        self.__zerofound = False
        

        while self.__zerofound == False:
            # a while loop that will always run until a value is returned
            
            
            # self.__x1 is assumed to be smaller than self.__x2
            self.__preconditionsmet = False
            
            # below code is for checking if the preconditions are met
            if self.__x1 != self.__x2:
            # first precondition is whether or not x1 is unequal to x2
            # if the first precondition is true, move on to the next precondition
            
                self.__y1 = Polynomial.f(Poly, self.__x1)
                self.__y2 = Polynomial.f(Poly, self.__x2)
                # the values of f(x1) and f(x2) are initialized
                
                if ((self.__y1 > 0 and self.__y2 < 0) or (self.__y1 < 0 and self.__y2 > 0)):
                # second precondition is whether or not the sign of f(x1) is the opposite of the sign of f(x2),
                # this is checked by looking at whether or not one variable is smaller than zero while the
                # other is bigger than zero
                    self.__preconditionsmet = True
                    
                    
            if self.__preconditionsmet == False:
                # if the preconditions are not met, it is assumed that no solution exists
                return ("There is no solution between", self.__x1, "and", self.__x2)
            else:
                # if the preconditions are met, the average of x1 and x2 is found
                self.__x0 = (self.__x1 + self.__x2) / 2
                
                
                while (self.__x1 < self.__x0 < self.__x2):
                    if ("%.3f" % Polynomial.f(self.__x0)) == "0.000":
                        # if f(x0) is sufficiently close enough to zero, where it can be rounded down to
                        # 0.000, than x0 will be returned
                        return self.__x0
                    elif Polynomial.f(self.__x0) > 0:
                        # if x0 does not sufficiently round to zero, and is larger than 0, it
                        # is assumed that the zero is inbetween x0 and x2
                        self.__x1 = self.__x0
                        # the value of x1 is assigned to x0, breaking the while loop above
                        # and restarting the algorithm with a new x1 value
                    elif Polynomial.f(self.__x0) < 0:
                        # if x0 does not sufficiently round to zero, and is larger than 0, it
                        # is assumed that the zero is inbetween x1 and x0
                        self.__x2 = self.__x0
                    else:
                        return "error"
    
                    

        

# IVT.py ends here

# polynomial driver starts here

# Irash Gilani
# 846852
# Driver Code for the Polynomial Object in the Final Project

# Variable Dictionary:
#
#
#
#
#
#
#

#from polynomial import Polynomial

P = Polynomial([0, 0, 1, 2, 0, 3, 0, 0])
print(P)
for i in range(10):
 print(i, P.f(i))
print("The order is", P.get_order())

# polynomial driver ends here

# ivtdriver.py starts here



# Irash Gilani
# 846852
# Driver Code for the IVT Object in the Final Project

# Variable Dictionary:
#
#
#
#
#
#
#

#from IVT import IVT

IVT(P, -2, -1)

# ivtdriver.py ends here
